 config.plugins.push(
          new WorkboxPlugin.GenerateSW({
            swDest: '../public/sw.js',
            exclude: [
              ({ asset, compilation }) => {
                if (
                  asset.name.match(
                    /^(build-manifest\.json|react-loadable-manifest\.json)$/
                  )
                ) {
                  return true;
                }
                if (dev && !asset.name.startsWith('static/runtime/')) {
                  return true;
                }
                if (experimental.modern /* modern */) {
                  if (asset.name.endsWith('.module.js')) {
                    return false;
                  }
                  if (asset.name.endsWith('.js')) {
                    return true;
                  }
                }
                return false;
              },
            ],
            manifestTransforms: [
              async (manifestEntries, compilation) => {
                const manifest = manifestEntries.map((m) => {
                  m.url = m.url.replace(/\/\[/g, '/%5B').replace(/\]/g, '%5D');
                  m.revision = buildId;
                  return m;
                });
                return { manifest, warnings: [] };
              },
            ],
            modifyURLPrefix: {
              [prefix]: path.posix.join('/', '/_next/static/'),
            },
            runtimeCaching: [
              {
                // Match any request that ends with .png, .jpg, .jpeg or .svg.
                urlPattern: /\.(?:png|jpg|jpeg|svg)$/,

                // Apply a cache-first strategy.
                handler: 'CacheFirst',

                options: {
                  // Use a custom cache name.
                  cacheName: 'start-url',
                  plugins: [
                    {
                      cacheWillUpdate: async ({
                        request,
                        response,
                        event,
                        state,
                      }) => {
                        if (response && response.type === 'opaqueredirect') {
                          return new Response(response.body, {
                            status: 200,
                            statusText: 'OK',
                            headers: response.headers,
                          });
                        }
                        return response;
                      },
                    },
                  ],
                },
              },
            ],
          })
        );